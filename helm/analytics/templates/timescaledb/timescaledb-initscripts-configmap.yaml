{{- $webapp := .Values.timescaledb -}}
{{- if $webapp.builtin -}}

apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "analytics.fullname" . }}-timescaledb-initscripts
  labels:
    {{- include "analytics.labels" . | nindent 4 }}
    app.kubernetes.io/component: {{ include "analytics.fullname" . }}-timescaledb
data:
  100_analytics_init.sql: |-
    CREATE SCHEMA IF NOT EXISTS analytics;
    SET search_path = analytics, public;
    CREATE UNLOGGED TABLE IF NOT EXISTS analytics.opentelemetry_buffer
    (
        timestamp                   timestamptz,
        span_id                     text,
        trace_id                    text,
        message                     text,
        attributes                  jsonb,
        resources                   jsonb,
        scope                       jsonb,
        source_type                 text,
        severity_text               text,
        severity_number             integer,
        observed_timestamp          timestamptz,
        flags                       integer,
        dropped_attributes_count    integer
    );
    COMMENT ON TABLE analytics.opentelemetry_buffer IS 'Opentelemetry buffer table. Receives incoming opentelemetry logs data, for further processing and proper storage. Only contains transient data.';
    
    CREATE TABLE IF NOT EXISTS analytics.access_logs
    (
        oid                  serial,
        id                   text,
        ts                   timestamptz NOT NULL,
        message              text        NOT NULL,
        app_id               text        NOT NULL,
        app_path             text        NOT NULL,
        app_name             text        NOT NULL,
        ip                   text,
        user_id              text,
        user_name            text,
        org_id               text,
        org_name             text,
        roles                text[],
        auth_method          text,
        request_method       text,
        request_path         text,
        request_query_string text,
        request_details      jsonb,
        response_time        integer,
        response_size        integer,
        status_code          integer,
        client_ip            text,
        server_address       text,
        context_data         jsonb,
        PRIMARY KEY (ts, oid)
    );
    SELECT create_hypertable('analytics.access_logs', by_range('ts', INTERVAL '7 days'));
    COMMENT ON TABLE analytics.access_logs IS 'Storage (hyper)table for the access logs processed data. This is a timescaledb-enabled table.';
    
    CREATE UNIQUE INDEX idx_id_timestamp
      ON analytics.access_logs(ts, id);
    
    -- Set retention policy to 3 years, see https://docs.timescale.com/api/latest/data-retention/add_retention_policy/#add_retention_policy
    SELECT add_retention_policy('analytics.access_logs', drop_after => INTERVAL '3 years', schedule_interval => INTERVAL '1 week');
    
    -- set compression
    -- see https://docs.timescale.com/api/latest/compression/alter_table_compression/
    --     https://docs.timescale.com/use-timescale/latest/compression/compression-policy/
    ALTER TABLE access_logs SET (
      timescaledb.compress,
      timescaledb.compress_segmentby = 'id'
    );
    SELECT add_compression_policy('access_logs', compress_after => INTERVAL '1 month');
  101_analytics_geoserver_views.sql: |-
    SET search_path = analytics, public;
    
    CREATE MATERIALIZED VIEW analytics.ogc_summary_hourly
    WITH (timescaledb.continuous) AS
    SELECT time_bucket(INTERVAL '1 h', ts, '{{ $webapp.timezone }}') AS bucket_hourly,
        app_id,
        app_name,
        user_name,
        org_name,
        request_method,
        status_code,
        server_address,
        request_details ->> 'workspaces' AS workspaces,
        request_details ->> 'layers' AS layers,
        request_details ->> 'service'            AS service,
        request_details ->> 'request'            AS request,
        request_details ->> 'tiled'              AS tiled,
        request_details ->> 'is_download'       AS is_download,
        request_details ->> 'download_format'   AS download_format,
        request_details ->> 'user_agent_family' AS user_agent_family,
        count(id)                               AS nb_req,
        AVG(response_time)                      AS avg_time,
        percentile_agg(response_time::DOUBLE PRECISION)         AS percentile_hourly
    FROM analytics.access_logs
    WHERE request_details ->'tags' @> '["ogc"]'
    GROUP BY bucket_hourly, app_id, app_name, user_name, org_name, request_method, status_code, server_address,
        request_details ->> 'workspaces', request_details ->> 'layers',
        request_details ->> 'service', request_details ->> 'request' , request_details ->> 'tiled',
        request_details ->> 'is_download', request_details ->> 'download_format', request_details ->> 'user_agent_family';
    
    -- for explanations about the percentile_agg see
    -- https://docs.timescale.com/use-timescale/latest/continuous-aggregates/hierarchical-continuous-aggregates/#roll-up-calculations
    
    
    SELECT add_retention_policy('analytics.ogc_summary_hourly', drop_after => INTERVAL '3 weeks', schedule_interval => INTERVAL '1 day');
    
    -- set compression
    -- see https://docs.timescale.com/use-timescale/latest/continuous-aggregates/compression-on-continuous-aggregates/
    SELECT add_continuous_aggregate_policy('analytics.ogc_summary_hourly',
      initial_start => '2025-11-11 00:00:05',
      start_offset => INTERVAL '7 days',
      end_offset => INTERVAL '0 hours',
      schedule_interval => INTERVAL '1 hour');
    ALTER MATERIALIZED VIEW analytics.ogc_summary_hourly set (timescaledb.compress = true);
    SELECT add_compression_policy('analytics.ogc_summary_hourly', compress_after=>'4 days'::interval);
    
    
    CREATE MATERIALIZED VIEW analytics.ogc_summary_daily
    WITH (timescaledb.continuous) AS
    SELECT  time_bucket(INTERVAL '1 d', bucket_hourly, '{{ $webapp.timezone }}') AS bucket_daily,
        app_id,
        app_name,
        user_name,
        org_name,
        request_method,
        status_code,
        server_address,
        workspaces,
        layers,
        service,
        request,
        tiled,
        is_download,
        download_format,
        user_agent_family,
        SUM(nb_req)                       AS nb_req,
        mean(rollup(percentile_hourly))   AS avg_time,
        rollup(percentile_hourly) as percentile_daily
    FROM analytics.ogc_summary_hourly
    GROUP BY bucket_daily, app_id, app_name, user_name, org_name, request_method, status_code, server_address, workspaces,
         layers, service, request, tiled, is_download, download_format, user_agent_family;
    
    SELECT add_retention_policy('analytics.ogc_summary_daily', drop_after => INTERVAL '2 years', schedule_interval => INTERVAL '1 week');
    
    -- set compression
    -- see https://docs.timescale.com/use-timescale/latest/continuous-aggregates/compression-on-continuous-aggregates/
    SELECT add_continuous_aggregate_policy('analytics.ogc_summary_daily',
      initial_start => '2025-11-11 00:00:05',
      start_offset => INTERVAL '3 weeks',
      end_offset => INTERVAL '0 hours',
      schedule_interval => INTERVAL '1 d');
    ALTER MATERIALIZED VIEW analytics.ogc_summary_daily set (timescaledb.compress = true);
    SELECT add_compression_policy('analytics.ogc_summary_daily', compress_after=>'4 weeks'::interval);
    
    
    
    CREATE MATERIALIZED VIEW analytics.ogc_summary_monthly
    WITH (timescaledb.continuous) AS
    SELECT  time_bucket(INTERVAL '1 month', bucket_daily, '{{ $webapp.timezone }}') AS bucket_monthly,
        app_id,
        app_name,
        user_name,
        org_name,
        request_method,
        status_code,
        server_address,
        workspaces,
        layers,
        service,
        request,
        tiled,
        is_download,
        download_format,
        user_agent_family,
        SUM(nb_req)                      AS nb_req,
        mean(rollup(percentile_daily))   AS avg_time,
        rollup(percentile_daily) as percentile_monthly
    FROM analytics.ogc_summary_daily
    GROUP BY bucket_monthly, app_id, app_name, user_name, org_name, request_method, status_code, server_address, workspaces,
         layers, service, request, tiled, is_download, download_format, user_agent_family;
    
    -- set compression
    -- see https://docs.timescale.com/use-timescale/latest/continuous-aggregates/compression-on-continuous-aggregates/
    SELECT add_continuous_aggregate_policy('analytics.ogc_summary_monthly',
      initial_start => '2025-11-11 00:00:05',
      start_offset => INTERVAL '6 months',
      end_offset => INTERVAL '0 hours',
      schedule_interval => INTERVAL '1 month');
    ALTER MATERIALIZED VIEW analytics.ogc_summary_monthly set (timescaledb.compress = true);
    SELECT add_compression_policy('analytics.ogc_summary_monthly', compress_after=>'7 months'::interval);
    
    
    CALL refresh_continuous_aggregate('analytics.ogc_summary_hourly', '2021-05-01', '2026-05-14');
    CALL refresh_continuous_aggregate('analytics.ogc_summary_daily', '2021-05-01', '2026-05-14');
    CALL refresh_continuous_aggregate('analytics.ogc_summary_monthly', '2021-05-01', '2026-05-14');
    
    
    -- Watch retention policies state (see https://docs.timescale.com/api/latest/data-retention/add_retention_policy/#add_retention_policy):
    -- SELECT j.hypertable_name,                                                                       
    --        j.job_id,
    --        config,
    --        schedule_interval,
    --        job_status,
    --        last_run_status,
    --        last_run_started_at,
    --        js.next_start,
    --        total_runs,
    --        total_successes,
    --        total_failures
    --   FROM timescaledb_information.jobs j
    --   JOIN timescaledb_information.job_stats js
    --     ON j.job_id = js.job_id
    --   WHERE j.proc_name = 'policy_retention';

{{- end }}